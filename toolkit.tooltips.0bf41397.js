/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/assets/toolkit/scripts/modules/tooltips.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/assets/toolkit/scripts/modules/tooltips.js":
/*!********************************************************!*\
  !*** ./src/assets/toolkit/scripts/modules/tooltips.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/helpers */ \"./src/assets/toolkit/scripts/utils/helpers.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n/** Library-specific polyfills (not shared anywhere else) */\n\nif ('NodeList' in window && !NodeList.prototype.forEach) {\n  console.info('polyfill for IE11');\n\n  NodeList.prototype.forEach = function (callback, thisArg) {\n    thisArg = thisArg || window;\n\n    for (var i = 0; i < this.length; i++) {\n      callback.call(thisArg, this[i], i, this);\n    }\n  };\n} // API interface\n\n\nvar tooltipsApi = window.toolkitTooltips || {};\n/**\n * A module providing basic tooltips UI and functionality.\n * Can be accessed globally through `window.toolkitTooltips` or\n * imported/required as a JS module.\n *\n * @typedef {Object} toolkitTooltip\n *\n * @property {function} initTooltip\n * @property {function} initTooltips\n * @property {function} getAllTooltips\n * @property {function} destroyAllTooltips\n */\n\n(function ToolkitTooltip() {\n  if (window.toolkitTooltips) {\n    // Available already - do not initialise again!\n    return;\n  }\n\n  window.toolkitTooltips = tooltipsApi; // Import for a global access\n\n  /** @constant */\n\n  var VALUE_ID = 'toolkit-tooltip',\n      ATTRIBUTE_NAME_TOOLTIP = 'data-tooltip',\n      ATTRIBUTE_NAME_CONTENT = 'title',\n      SIZES = {\n    SCREEN_PADDING: 20,\n    MAX_WIDTH: 400,\n    CARET_SIZE: 20\n  },\n      TRIGGER_TYPE = {\n    HOVER: 'hover',\n    CLICK: 'click'\n  };\n  /** PRIVATE MEMBERS */\n\n  var globalTooltipElement, lastInteractedSourceElement, outsideClickListenerFn;\n  /** List of active tooltips */\n\n  var tooltipsList = [];\n  /** PRIVATE FUNCTIONS */\n\n  function appendTooltipElement() {\n    var tooltipElement = document.createElement('div');\n    tooltipElement.setAttribute('id', VALUE_ID);\n    tooltipElement.setAttribute('class', 'tooltip');\n    tooltipElement.setAttribute('role', 'tooltip');\n    tooltipElement.setAttribute('hidden', '');\n    document.body.appendChild(tooltipElement);\n    globalTooltipElement = tooltipElement;\n  }\n\n  function removeTooltipElement() {\n    globalTooltipElement = undefined;\n    document.body.removeChild(globalTooltipElement);\n  }\n  /** INLINE CLASSES. */\n\n  /**\n   * Takes care of all the data and UI operations\n   *\n   * @typedef {Class} Tooltip\n   *\n   * @property {Element} sourceElement\n   * @property {string} content\n   * @property {string} triggerType\n   *\n   * @property {function} destroy\n   * @property {function} showTooltip\n   * @property {function} hideTooltip\n   * @property {function} toggleTooltip\n   *\n   */\n\n\n  var Tooltip =\n  /*#__PURE__*/\n  function () {\n    /**\n     * @param {Element} sourceElement -\n     *  DOM Element that will toggle the tooltip.\n     * @param {{content:string, attributeNameContent:string,trigger:string}} -\n     *   Optional custom settings.\n     *\n     * @memberof Tooltip\n     */\n    function Tooltip(sourceElement) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          content = _ref.content,\n          _ref$attributeNameCon = _ref.attributeNameContent,\n          attributeNameContent = _ref$attributeNameCon === void 0 ? ATTRIBUTE_NAME_CONTENT : _ref$attributeNameCon,\n          _ref$trigger = _ref.trigger,\n          trigger = _ref$trigger === void 0 ? TRIGGER_TYPE.HOVER : _ref$trigger;\n\n      _classCallCheck(this, Tooltip);\n\n      this.sourceElement = sourceElement;\n      this.content = content || sourceElement.getAttribute(attributeNameContent);\n      this.triggerType = trigger;\n\n      if (this.content) {\n        this.init();\n      } else {\n        console.warn('There is no available content to show in the tooltip for element. The tooltip will not be created. ', this.sourceElement, this.content);\n      }\n\n      this.bindEvents();\n      this.enhanceAccessibility();\n    }\n    /** PUBLIC METHODS */\n\n    /** Removes the tooltip and cleans up. */\n\n\n    _createClass(Tooltip, [{\n      key: \"destroy\",\n      value: function destroy() {\n        // Remove this instance from the list of tooltips\n        var tooltipIndex = tooltipsList.indexOf(this);\n\n        if (tooltipIndex > -1) {\n          tooltipsList.splice(tooltipIndex, 1); // TODO: + Unbind all events\n        }\n\n        if (tooltipsList.length === 0) removeTooltipElement();\n      }\n    }, {\n      key: \"showTooltip\",\n      value: function showTooltip($event) {\n        // Mobile Safari *ONLY* quirk: https://developer.mozilla.org/en-US/docs/Web/Events/click#Safari_Mobile\n        if (Object(_utils_helpers__WEBPACK_IMPORTED_MODULE_0__[\"isAppleMobileDevice\"])()) document.body.style.cursor = 'pointer';\n        Object(_utils_helpers__WEBPACK_IMPORTED_MODULE_0__[\"removeAttribute\"])(this.sourceElement, 'title'); // Remove title attribute to prevent default system behavior\n\n        this.sourceElement.setAttribute('aria-describedby', VALUE_ID); // Accessibility\n\n        Object(_utils_helpers__WEBPACK_IMPORTED_MODULE_0__[\"removeAttribute\"])(globalTooltipElement, 'hidden'); // Accessibility\n\n        globalTooltipElement.style.opacity = 0; // FIXME: SHOULD support HTML-based content too!\n\n        globalTooltipElement.textContent = this.content;\n        globalTooltipElement.style.display = 'block';\n        this.positionTooltip();\n        return $event;\n      }\n    }, {\n      key: \"hideTooltip\",\n      value: function hideTooltip($event) {\n        globalTooltipElement.style.opacity = 0; // TODO: Animate disappearance\n\n        this.sourceElement.setAttribute(ATTRIBUTE_NAME_CONTENT, this.content);\n        Object(_utils_helpers__WEBPACK_IMPORTED_MODULE_0__[\"removeAttribute\"])(this.sourceElement, 'aria-describedby');\n        globalTooltipElement.setAttribute('hidden', ''); // Accessibility\n        // Mobile Safari *ONLY* quirk: https://developer.mozilla.org/en-US/docs/Web/Events/click#Safari_Mobile\n\n        if (Object(_utils_helpers__WEBPACK_IMPORTED_MODULE_0__[\"isAppleMobileDevice\"])()) document.body.style.cursor = null;\n        globalTooltipElement.style.display = 'none';\n        return $event;\n      }\n    }, {\n      key: \"toggleTooltip\",\n      value: function toggleTooltip($event) {\n        var _this = this;\n\n        if (Object(_utils_helpers__WEBPACK_IMPORTED_MODULE_0__[\"isElementHidden\"])(globalTooltipElement)) {\n          if (outsideClickListenerFn) window.removeEventListener('click', outsideClickListenerFn);\n          outsideClickListenerFn = this.handleClickOutsideTooltip.bind(this);\n          window.addEventListener('click', outsideClickListenerFn);\n          this.showTooltip($event);\n        } else {\n          window.removeEventListener('click', outsideClickListenerFn);\n          this.hideTooltip($event);\n\n          if (lastInteractedSourceElement !== this.sourceElement) {\n            setTimeout(function () {\n              // `setTimeout()` forces the tooltip to re-open (by pushing it into )\n              _this.toggleTooltip($event);\n            });\n          }\n        }\n\n        lastInteractedSourceElement = this.sourceElement;\n      }\n      /** PRIVATE FUNCTIONS */\n\n      /** Builds tooltip, attaches events and adds generic DOM. */\n\n    }, {\n      key: \"init\",\n      value: function init() {\n        tooltipsList.push(this); // First initiated tooltip -> add the global tooltip element\n\n        if (tooltipsList.length === 1) appendTooltipElement();\n      }\n    }, {\n      key: \"bindEvents\",\n      value: function bindEvents() {\n        if (this.triggerType === TRIGGER_TYPE.CLICK) {\n          this.sourceElement.addEventListener('click', this.toggleTooltip.bind(this));\n        } else if (this.triggerType === TRIGGER_TYPE.HOVER) {\n          this.bindMouseHovering();\n          this.bindAccessibilityFeatures();\n        } else {\n          console.error('Unsupported type of trigger `%s`. The tooltip will not be shown for your element', this.triggerType, this.sourceElement);\n        }\n      }\n    }, {\n      key: \"bindAccessibilityFeatures\",\n      value: function bindAccessibilityFeatures() {\n        this.sourceElement.addEventListener('focus', this.showTooltip.bind(this));\n        this.sourceElement.addEventListener('focusout', this.hideTooltip.bind(this));\n        this.sourceElement.addEventListener('keydown', this.hideTooltipOnEscKey.bind(this));\n      }\n    }, {\n      key: \"bindMouseHovering\",\n      value: function bindMouseHovering() {\n        this.sourceElement.addEventListener('mouseenter', this.showTooltip.bind(this));\n        this.sourceElement.addEventListener('mouseout', this.hideTooltip.bind(this));\n      }\n    }, {\n      key: \"enhanceAccessibility\",\n      value: function enhanceAccessibility() {\n        this.sourceElement.setAttribute('tabindex', 0);\n      }\n    }, {\n      key: \"handleClickOutsideTooltip\",\n      value: function handleClickOutsideTooltip($event) {\n        if ($event.target !== this.sourceElement && $event.target !== globalTooltipElement) {\n          window.removeEventListener('click', outsideClickListenerFn);\n          this.hideTooltip($event);\n        }\n      }\n    }, {\n      key: \"hideTooltipOnEscKey\",\n      value: function hideTooltipOnEscKey($event) {\n        var KEY_ESC_ID = 27;\n\n        if ($event.which === KEY_ESC_ID) {\n          this.hideTooltip();\n          $event.preventDefault();\n          return false;\n        }\n\n        return true;\n      }\n    }, {\n      key: \"getSourceElementCenterX\",\n      value: function getSourceElementCenterX() {\n        return this.sourceElement.getBoundingClientRect().left + this.sourceElement.getBoundingClientRect().width / 2;\n      }\n    }, {\n      key: \"calculateTooltipPositionX\",\n      value: function calculateTooltipPositionX() {\n        var positionX = 0;\n        var expectedTooltipWidth = Math.floor(globalTooltipElement.getBoundingClientRect().width),\n            viewPortWidth = window.innerWidth,\n            caretOffset = 20,\n            // Half of the caret size + margin from the edge of the tooltip\n        elementCenterX = this.getSourceElementCenterX(),\n            potentialTooltipLeftPositionX = elementCenterX - caretOffset,\n            potentialTooltipRightPositionX = elementCenterX - expectedTooltipWidth + caretOffset;\n\n        if (viewPortWidth < potentialTooltipLeftPositionX + expectedTooltipWidth && elementCenterX - caretOffset >= 0) {\n          globalTooltipElement.classList.add('right');\n          positionX = potentialTooltipRightPositionX;\n        } else {\n          // Default\n          globalTooltipElement.classList.add('left');\n          positionX = potentialTooltipLeftPositionX;\n        }\n\n        return positionX;\n      }\n    }, {\n      key: \"calculateTooltipPositionY\",\n      value: function calculateTooltipPositionY() {\n        var positionY = 0;\n        var caretOffset = 16,\n            // Caret's height + margin between the tip and the element\n        expectedTooltipHeight = globalTooltipElement.getBoundingClientRect().height,\n            viewPortTopY = window.window.pageYOffset,\n            viewPortBottomY = viewPortTopY + window.innerHeight,\n            elementTopY = this.sourceElement.getBoundingClientRect().top,\n            elementBottomY = elementTopY + this.sourceElement.getBoundingClientRect().height,\n            potentialTooltipTopPositionY = elementTopY - caretOffset - expectedTooltipHeight,\n            potentialTooltipBottomPositionY = elementBottomY + caretOffset;\n\n        if (potentialTooltipTopPositionY < SIZES.SCREEN_PADDING && elementBottomY + caretOffset + expectedTooltipHeight <= viewPortBottomY - SIZES.SCREEN_PADDING) {\n          globalTooltipElement.classList.add('top');\n          positionY = potentialTooltipBottomPositionY;\n        } else {\n          // Default\n          globalTooltipElement.classList.add('bottom');\n          positionY = potentialTooltipTopPositionY;\n        }\n\n        return positionY + viewPortTopY;\n      }\n    }, {\n      key: \"setTooltipWidth\",\n      value: function setTooltipWidth() {\n        // Pre-calculate required dimensions\n        var expectedTooltipWidth = Math.floor(globalTooltipElement.getBoundingClientRect().width),\n            viewPortWidth = window.innerWidth,\n            caretOffset = 20,\n            // Half of the caret size + margin from the edge of the tooltip\n        elementCenterX = this.getSourceElementCenterX(),\n            potentialTooltipLeftPositionX = elementCenterX - caretOffset,\n            potentialTooltipRightPositionX = elementCenterX - expectedTooltipWidth + caretOffset,\n            potentialTooltipLeftSpace = viewPortWidth - potentialTooltipLeftPositionX,\n            potentialTooltipRightSpace = potentialTooltipRightPositionX + expectedTooltipWidth; // 2. Check if the tooltip is going to fit there\n\n        if (potentialTooltipLeftSpace - SIZES.SCREEN_PADDING >= expectedTooltipWidth || potentialTooltipRightSpace - SIZES.SCREEN_PADDING >= expectedTooltipWidth) {\n          globalTooltipElement.style.width = \"\".concat(expectedTooltipWidth + 1, \"px\");\n          return;\n        }\n\n        if (potentialTooltipLeftSpace < potentialTooltipRightSpace) {\n          // Tooltip right is better\n          globalTooltipElement.style.width = \"\".concat(potentialTooltipRightSpace - SIZES.SCREEN_PADDING, \"px\");\n        } else {\n          // Tooltip left is better\n          globalTooltipElement.style.width = \"\".concat(potentialTooltipLeftSpace - SIZES.SCREEN_PADDING, \"px\");\n        }\n      }\n    }, {\n      key: \"positionTooltip\",\n      value: function positionTooltip() {\n        // Reset positioning classes\n        globalTooltipElement.classList.remove('left');\n        globalTooltipElement.classList.remove('right');\n        globalTooltipElement.classList.remove('top');\n        globalTooltipElement.classList.remove('bottom');\n        globalTooltipElement.style.width = ''; // Revert into 'auto'\n\n        globalTooltipElement.style.height = ''; // Revert into 'auto'\n\n        this.setTooltipWidth();\n        globalTooltipElement.style.left = \"\".concat(this.calculateTooltipPositionX(), \"px\");\n        globalTooltipElement.style.top = \"\".concat(this.calculateTooltipPositionY(), \"px\");\n        globalTooltipElement.style.opacity = 1;\n      }\n    }]);\n\n    return Tooltip;\n  }();\n  /** PUBLIC METHODS. */\n\n  /**\n   * Initialises a tooltip for a given element. If the `configObject` is not\n   * passed, it tries to parse it from a `data-tooltip` attribute (JSON-valid\n   * string object) of the element.\n   *\n   * @param {Element} tooltipableElement -\n   *    A single element that should be used to initialise a tooltip.\n   * @param {Object} configObject -\n   *    Object specifying configurable options to adjust tooltip's behaviour.\n   *\n   * @return {Tooltip}\n   */\n\n\n  function initTooltip(tooltipableElement, configObject) {\n    var tooltipConfigObject = configObject;\n    var tooltipElementConfigString = tooltipableElement.getAttribute(ATTRIBUTE_NAME_TOOLTIP);\n\n    if (!tooltipConfigObject && tooltipElementConfigString && tooltipConfigObject !== '') {\n      try {\n        tooltipConfigObject = JSON.parse(tooltipElementConfigString);\n      } catch (err) {\n        console.error('Custom configuration options for a tooltip MUST be in a valid JSON format: ', tooltipElementConfigString, tooltipableElement, err);\n      }\n    }\n\n    return new Tooltip(tooltipableElement, tooltipConfigObject);\n  }\n  /**\n   * If no parameter is passed, auto-initialise a tooltip for all\n   * elements that contain `data-tooltip` attribute.\n   *\n   * @param {Array<Element>} tooltipableDomElements -\n   *    A list of all elements to initialise a tooltip for.\n   *\n   * @return {Array<Tooltip>|null} List of newly created Tooltips.\n   */\n\n\n  function initTooltips(tooltipableDomElements) {\n    /** @type {NodeList} */\n    var tooltipableElementList = tooltipableDomElements || document.querySelectorAll(\"[\".concat(ATTRIBUTE_NAME_TOOLTIP, \"]\"));\n    var newTooltipInstances = [];\n    tooltipableElementList.forEach(function (element) {\n      return newTooltipInstances.push(initTooltip(element));\n    });\n    return newTooltipInstances.length > 0 ? newTooltipInstances : null;\n  }\n  /**\n   * Retrieves all existing active tooltips.\n   *\n   * @return {Array<Tooltip>}\n   */\n\n\n  function getAllTooltips() {\n    return tooltipsList;\n  }\n  /**\n   * Removes all the Tooltips safely to prevent memory leaks.\n   *\n   * @returns {boolean}\n   */\n\n\n  function destroyAllTooltips() {\n    while (tooltipsList.length) {\n      tooltipsList[0].destroy();\n    }\n\n    return true;\n  } // Populate public API interface\n\n\n  tooltipsApi.initTooltip = initTooltip;\n  tooltipsApi.initTooltips = initTooltips;\n  tooltipsApi.getAllTooltips = getAllTooltips;\n  tooltipsApi.destroyAllTooltips = destroyAllTooltips;\n  /** MODULE INITIALISATIONS. */\n\n  /**\n   * Check for dependencies and report/auto-import if any are missing.\n   */\n\n  function areDependenciesAvailable() {}\n  /** @constructor */\n\n\n  function constructor() {}\n  /** Initialisations after the DOM becomes ready. */\n\n\n  function initOnDomReady() {}\n\n  (function init() {\n    if (!areDependenciesAvailable()) return;\n    constructor();\n    initOnDomReady();\n  })();\n})(); // Make API available for Modular JS codebases\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (tooltipsApi);\n\n//# sourceURL=webpack:///./src/assets/toolkit/scripts/modules/tooltips.js?");

/***/ }),

/***/ "./src/assets/toolkit/scripts/utils/helpers.js":
/*!*****************************************************!*\
  !*** ./src/assets/toolkit/scripts/utils/helpers.js ***!
  \*****************************************************/
/*! exports provided: checkHttpStatus, isElementHidden, hasProp, removeAttribute, isAppleMobileDevice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"checkHttpStatus\", function() { return checkHttpStatus; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isElementHidden\", function() { return isElementHidden; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasProp\", function() { return hasProp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeAttribute\", function() { return removeAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isAppleMobileDevice\", function() { return isAppleMobileDevice; });\n/**\n * Utility library with helper functions.\n *\n * It **SHOULD NOT** be used as a standalone library, but only\n * imported as a dependency.\n *\n * Add **ONLY** function that are generic enough to be reused\n * by almost any module.\n */\n\n/**\n * Checks HTTP response status and if permitted (200-299), passes the response.\n * Otherwise, an exception is thrown.\n *\n * @param {Response} response\n * @throws {Error}\n */\nfunction checkHttpStatus(response) {\n  if (response.status >= 300 || response.status < 200) {\n    var error = new Error(\"Incorrect response HTTP status #\".concat(response.status, \" (\").concat(response.statusText, \") received.\"));\n    error.response = response;\n    throw error;\n  }\n\n  return response;\n}\n/**\n * Checks whether an element is `display: none;` or not.\n *\n * @param {Element} element - DOM Element.\n *\n * @return {boolean}\n */\n\nfunction isElementHidden(element) {\n  return element.offsetParent === null; // *ONLY* happens when the element is not fixed\n}\n/**\n * Tests whether a property/attribute exists on a given {Object}. This is a\n * safe implementation of `Object.hasOwnProperty()`\n *\n * @param {Object} obj - Object to test the existence of the attribute on.\n * @param {String} propName - Name of the attribute to test.\n */\n\nfunction hasProp(obj, propName) {\n  return Object.prototype.hasOwnProperty.call(obj, propName);\n}\n/**\n * Remove attribute from a DOM Element in a browser-compatible manner.\n *\n * @param {Element} domElement\n * @param {string} attributeName\n */\n\nfunction removeAttribute(domElement, attributeName) {\n  domElement.setAttribute(attributeName, false); // Hack for IE11 / MS Edge\n\n  domElement.removeAttribute(attributeName); // All other normal browsers\n}\n/**\n * Detects if the device is likely to be from Apple.\n * Should only be used for fixing or hacking critical issues.\n *\n * @param {String} customUserAgent -\n *  Allows to specify the HTTP Header's `User-Agent` string.\n *\n * @return {boolean}\n */\n\nfunction isAppleMobileDevice(customUserAgent) {\n  var userAgent = customUserAgent || (typeof window.navigator !== 'undefined' ? window.navigator.userAgent : '');\n  return /iPhone|iPod|iPad/i.test(userAgent) && !/Windows Phone/i.test(userAgent);\n}\n\n//# sourceURL=webpack:///./src/assets/toolkit/scripts/utils/helpers.js?");

/***/ })

/******/ });